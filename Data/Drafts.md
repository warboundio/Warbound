# Data Drafts

## Draft: Implement QuestDiscoveryETL
## Agent
This is bit different than usual. So here we have two ways to discover a quest. The QuestCategoryEndpoint and the QuestAreaEndpoint. We need to create a new ETL called QuestDiscoveryETL. This ETL will be responsible for discovering quests based on the category and area endpoints.They should loop through each of their DbContext's rows calling each endpoint and get a list of quest ids to potentially add. The ETL should first get all ids currently in the database. For each id that comes back, a quest stub should be created with the id, a status of NEEDS_ENRICHMENT, and a QuestIdentifier of either CATEGORY or AREA. The QuestIdentifierId should be set to the id of the category or area. The date should be set. The ETL should then save these stubs to the database. If a stub already exists, it should not be added again..

## Draft: Implement QuestETL
## Agent
Ok this will be the most complicated one, so while we want to watch others' patterns for coding standards this will be a bit more specific to itself. We have a Quest.json. We need to unit test that the endpoint we're going to create can parse it properly. The ValidatorETL should check the schema. We have three ETLs creating these Quest objects: QuestCategoryETL, QuestAreaETL, and QuestTypeETL. We need to call the blizzard endpoint located at: https://us.api.blizzard.com/data/wow/quest/2?namespace=static-us&locale=en_US for each object with a status of NEEDS_ENRICHMENT. We need to populate the Quest object with the data from the endpoint and then put it in the database with a status of COMPLETE. So it looks like i misunderstood the structure and schema a bit. On this object we have BOTH QuestType and QuestArea. So we need to REMOVE the option for 'QuestIdentifier' to be a TYPE. We need to ADD a property to the Quest object called QuestTypeId which will be parsed from our Quest.json at the property 'type.id' (if it exists otherwise 0). We need to check if it has an 'Area' property as the example json does, if it does, we need to set the QuestIdentifier to AREA and set the 'area.id'. I added a 'Quest2.json' to the repo to demonstrate how a QuestCategory type of 'QuestIdentifier' should look like. Here we need to set the QuestIdentifier as 'CATEGORY' and the QuestIdentifierId to 'category.id'. Ok now let's look at additional properties needed, We need a semicolon delimited list of RewardItems. Quest.json has an example structure where 'rewards.items.choice_of' exists and Quest2 does not. If it does exist, we want to get a semi column delimited list of the 'rewards.items.choice_of.item.id' for each of the choices. We do not want the requirements or playable_specializations. There's a lot of information we don't need in here. 

## Draft: Attach Addon Objects to Database
## Agent
Under Data/Addon we have identified a number of objects that we can gather from our addon to store in our database. These objects are not yet ready for migration. They should follow the same structure as our blizzardapi/endpoints objects. Ensure maxlength maxes sense for each column. wow is the schema. and let's prefix all of our tables with 'g_' to denote that it's generated. Following that prefix let's make a name that follows the patterns of the context. Let's also ensure they are added to the context and let's just keep the structure of 'G_' as a prefix even in the context so we clearly know which are generated. 